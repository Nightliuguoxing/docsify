# ML16 - Octave Tutorial Computing on data

### 计算数据
```octave
>> A = [1 2 ; 3 4 ; 5 6]
A =

   1   2
   3   4
   5   6

>> B = [11 12 ; 13 14 ; 15 16]
B =

   11   12
   13   14
   15   16

>> C = [1 1 ; 2 2]
C =

   1   1
   2   2

>> A*C
ans =

    5    5
   11   11
   17   17

>> A .* B % 对应位置元素相乘
ans =

   11   24
   39   56
   75   96

>> A .^ 2 % 对每个元素进行乘方处理
ans =

    1    4
    9   16
   25   36

>> v = [1; 2; 3]
v =

   1
   2
   3

>> 1 ./ v % 向量倒数
ans =

   1.0000
   0.5000
   0.3333

>> log(v) % 对数运算
ans =

        0
   0.6931
   1.0986

>> exp(v) % 
ans =

    2.7183
    7.3891
   20.0855

>> abs(v) % 绝对值
ans =

   1
   2
   3

>> -v % 相反数
ans =

  -1
  -2
  -3

>> v + ones(length(v), 1) % v + 1也行
ans =

   2
   3
   4

>> A' % A的转置
ans =

   1   3   5
   2   4   6

>> a = [1, 20, 0.5, -3]
a =

    1.0000   20.0000    0.5000   -3.0000

>> val = max(a) % 得到向量中的最大值
val = 20
>> [val, ind] = max(a) % val表示向量a中最大值 ind表示该元素的索引
val = 20
ind = 2
>> max(A) % 得到矩阵每一列的最大值
ans =

   5   6

>> a
a =

    1.0000   20.0000    0.5000   -3.0000

>> a < 3 % 对应元素的比较
ans =

  1  0  1  1
>> find(a < 3) % 查找元素
ans =

   1   3   4 % 索引位置一、三、四号元素满足条件

>> A = magic(3) % 幻方矩阵 每行每列每斜线加起来值相等
A =

   8   1   6
   3   5   7
   4   9   2


>> [r,c] = find(A >= 7)
r =

   1
   3
   2

c =

   1
   2
   3

>> a
a =

    1.0000   20.0000    0.5000   -3.0000

>> sum(a) % 求和函数
ans = 18.500
>> prod(a) % 乘积
ans = -30

>> floor(a) % 对元素下取整
ans =

    1   20    0   -3

>> ceil(a) % 对元素上取整
ans =

    1   20    1   -3

>> rand(3)
ans =

   9.2190e-01   7.2878e-01   4.4345e-01
   5.1287e-01   7.9862e-03   7.7783e-01
   2.8737e-01   8.8369e-01   1.6474e-01

>> max(rand(3), rand(3))
ans =

   0.8924   0.1106   0.9303
   0.9629   0.3846   0.1723
   0.4435   0.2659   0.4616

>> A
A =

   8   1   6
   3   5   7
   4   9   2

>> max(A, [], 1) % 获取每一列最大值 1表示从第一维度取值
ans =

   8   9   7
>> max(A, [], 2) % 获取每一行最大值 2表示从第二维度取值
ans =

   8
   7
   9


>> A = magic(9)
A =

   47   58   69   80    1   12   23   34   45
   57   68   79    9   11   22   33   44   46
   67   78    8   10   21   32   43   54   56
   77    7   18   20   31   42   53   55   66
    6   17   19   30   41   52   63   65   76
   16   27   29   40   51   62   64   75    5
   26   28   39   50   61   72   74    4   15
   36   38   49   60   71   73    3   14   25
   37   48   59   70   81    2   13   24   35

>> sum(A, 1) % 每一列的和
ans =

   369   369   369   369   369   369   369   369   369
>> sum(A, 2) % 每一行的和
ans =

   369
   369
   369
   369
   369
   369
   369
   369
   369
>> sum(sum(A .* eye(9))) % 正对角线的和
ans = 369
>> sum(sum(A .* flipud(eye(9)))) % 负对角线的和 flipud 垂直旋转
ans = 369

>> A = magic(3)
A =

   8   1   6
   3   5   7
   4   9   2

>> pinv(A) % A的逆矩阵
ans =

   0.147222  -0.144444   0.063889
  -0.061111   0.022222   0.105556
  -0.019444   0.188889  -0.102778

>> A * pinv(A) % 单位矩阵
ans =

   1.0000e+00  -1.1435e-14   6.2728e-15
  -2.7409e-16   1.0000e+00  -1.9429e-16
  -6.2034e-15   1.2546e-14   1.0000e+00
```