# 运算符号

### 算术运算符
- + 加法运算符
- - 减法运算符
- * 乘法运算符
- ** 幂运算符
- / 除法运算符
- // 整除运算符
- % 求模运算符
- = 赋值运算符
	- a = 10
	- b = a + c
	- a, b, c = 10, 20, 30
	- 链式赋值 a = b = c = 3
- 注意
	- 除以0
	- 优先级问题 ()使用
- 整除和求余的应用场景 行列

### 复合运算符
- +=
- -=
- *=
- %=
- **=
- //=
- a
	- a  x= 值
	- a = a x 值

### 比较运算符
- 比较运算符
	- \>
	- <
	- !=
	- <>
		- Python2.x版本支持
		- 等同于!=
		- 以后统一使用!=表示不等于
	- \>=
	- <=
	- ==
	- is
		- 比对唯一标识
	- 链状比较运算符
		- 10 < a <=66
	- 注意
		- 整型比对
			- ==
			- is
		- 解答
			- 出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256]之间的小对象放在small_ints中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。Python内部为了将性能进一步的提高，凡是在一个代码块中创建的整数对象，如果存在一个值与其相同的对象于该代码块中了，那么就直接引用，否则创建一个新的对象出来。Python出于对性能的考虑，但凡是不可变对象，在同一个代码块中的对象，只有是值相同的对象，就不会重复创建，而是直接引用已经存在的对象。因此，不仅是整数对象，还有字符串对象也遵循同样的原则。所以 a is b就理所当然的返回True了，而c和a不在同一个代码块中，因此在Python内部创建了两个值都是257的对象。

### 逻辑运算符
- 逻辑运算符
	- not
		- 非
		- 取反
			- 真的变假
			- 假的变真
	- and
		- 与
		- 一假全假
	- or
		- 或
		- 一真全真
	- 注意
		- 非布尔类型的值, 如果作为真假来判定, 一般都是非零即真, 非空即真
		- 整个逻辑表达式的结果不一定只是True和False